/*
 * Copyright (c) 2013 by Ernesto Carrella
 * Licensed under the Academic Free License version 3.0
 * See the file "LICENSE" for more information
 */

package agents.firm.production.control.targeter;

import agents.Person;
import agents.firm.personell.HumanResources;
import model.utilities.ActionOrder;
import model.utilities.pid.PIDController;
import com.google.common.base.Preconditions;
import financial.MarketEvents;
import agents.firm.production.Plant;
import agents.firm.production.control.PlantControl;
import agents.firm.production.technology.Machinery;
import sim.engine.SimState;
import sim.engine.Steppable;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

/**
 * <h4>Description</h4>
 * <p/> The standard PID workforce targeter.
 * Works very much like a purchase department control: increase wages when it needs workers,
 * decreases wages when it needs to fire people.
 * <p/>
 * <p/>
 * <h4>Notes</h4>
 * Created with IntelliJ
 * <p/>
 * <p/>
 * <h4>References</h4>
 *
 * @author Ernesto
 * @version 2012-09-22
 * @see
 */
public class PIDTargeter implements WorkforceTargeter, Steppable {

    /**
     * Current worker target
     */
    private int workerTarget = 0 ;

    /**
     * PID Controller
     */
    private final PIDController pid;

    /**
     * link to the human resources objects (and plant and all)
     */
    final private HumanResources hr;

    /**
     * The control we are part of
     */
    private final PlantControl plantControl;

    /**
     * is it activated?
     */
    boolean active = true;


    /**
     * A new PID targeter, the pid controller is randomly generated by drawing parameters from the model object
     * @param hr the human resources the PID target works with
     */
    public PIDTargeter(HumanResources hr, PlantControl control) {
        this(hr,new PIDController(hr.getFirm().getModel().drawProportionalGain(),hr.getFirm().getModel().drawIntegrativeGain(),
                hr.getFirm().getModel().drawDerivativeGain(),hr.getFirm().getModel().drawplantControlSpeed(),hr.getFirm().getRandom()),control);
    }

    /**
     * A new PID targeter, the controller will be created with the given parameters
     * @param hr the human resources the PID target works with
     */
    public PIDTargeter(HumanResources hr, PlantControl control,
                       float proportionalGain, float integrativeGain, float derivativeGain, int controlSpeed){
        this(hr,new PIDController(proportionalGain,integrativeGain,derivativeGain,controlSpeed,hr.getRandom()),control);
    }

    /**
     * A new PID targeter, with pre-specified controller
     * @param hr the human resources the PID target works with
     */
    public PIDTargeter(HumanResources hr,PIDController controller, PlantControl control) {
        this.hr = hr;
        this.pid = controller;
        controller.setRandomSpeed(true);
        this.plantControl =  control;
    }

    /**
     * The strategy is told that now we need to hire this many workers
     *
     * @param workerSizeTargeted the new number of workers we should target
     */
    @Override
    public void setTarget(int workerSizeTargeted) {
        workerTarget = workerSizeTargeted;
    }


    /**
     * This is your standard PID controller adjust with a few  modifications: it tries to fix rounding problems, and calls set currentWage only when there is a real change
     * @param simState
     */
    @Override
    public void step(SimState simState) {
        //don't go on if you aren't active
        if(!active)
            return;

        //remember old wage
        long oldWage = plantControl.maxPrice(hr.getGoodType());
        //if you are lowering wage, double check by ceiling (makes it sluggish to wage changes)
        boolean roundingAdjustment = false;


        //if firing: go into quickfiring mode:
        if(workerTarget < hr.getPlant().workerSize())
        {
            if(workerTarget != 0)
                quickfire();
            else
            {
                //set wages to 0
                setInitialWage(0); //set price to 0
                //fire directly everyone
                while(hr.getPlant().workerSize() > 0){
                    Person workerFired = hr.getPlant().removeLastWorker();
                    workerFired.fired(hr.getFirm());
                }
            }
        }

        //run the controller (it will reschedule us)
        pid.adjust(workerTarget, hr.getPlant().workerSize(), active, hr.getPlant().getModel(), this, ActionOrder.THINK);

        //todo document rounding
        //initially round
        long newWage = Math.round(pid.getCurrentMV());
        //if you are lowering wage, double check by ceiling (makes it sluggish to wage changes)
        if(newWage<oldWage)
        {
            newWage = (long) Math.ceil(pid.getCurrentMV());
            //remember you ceiled
            roundingAdjustment = true;
        }

        //if there was a REAL change call setCurrentWage of the control. Otherwise don't bother.
        if(oldWage != newWage && newWage >=0) //if pid says to change prices, change prices
        {
            plantControl.setCurrentWage(newWage); //set the new wage! that'll do it!
            //log it!
            hr.getFirm().logEvent(hr,
                    MarketEvents.CHANGE_IN_POLICY,
                    hr.getFirm().getModel().getCurrentSimulationTimeInMillis(),
                    "target: " + workerTarget + ", #workers:" + hr.getPlant().workerSize() +
                            "; oldwage:" + oldWage + ", newWage:" + newWage);

        }



        //TODO delete this: make it a decorator issue
        //try having your PID stable if you have no error twice
        if(pid.getNewError() == 0 && (pid.getOldError() ==0 || roundingAdjustment) && newWage == oldWage) //we are at the right place!
        {
            setInitialWage(plantControl.getCurrentWage());

        }

    }

    /**
     * utility to fire workers without trial and attempt: just target how many workers you want to fire and that's it
     */
    private void quickfire() {

        //make a list of workers
        List<Person> workers = new ArrayList<>(hr.getPlant().getWorkers());
        //sort them by their minimum wage
        Collections.sort(workers, new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                return Long.compare(o1.getMinimumWageRequired(), o2.getMinimumWageRequired());

            }
        });

        assert workers.size() >0;
        int workersToFire = hr.getPlant().workerSize() - workerTarget;
        assert workersToFire <= workers.size(): workersToFire + "---" + workers.size();
        assert workersToFire > 0;

        //set the wage and fire the workers
        long newWage = workers.get(workers.size() - workersToFire -1).getMinimumWageRequired();
        assert newWage == workers.get(workers.size() - workersToFire -1).getMinimumWageRequired();
        plantControl.setCurrentWage(newWage ); //set new wage
        //in normal situation the new wage will be the variable newwage, but maybe there are frictions. At which point your best bet is just to be slightly below it
        //for the time being
  //      newWage = newWage < plantControl.getCurrentWage() ? plantControl.getCurrentWage()-1 : newWage;
        setInitialWage(newWage);     //reset PID


        //and now fire them
        if(!hr.isFixedPayStructure())
            //if you are discriminating on pay, this is quite easy.
            hr.fireEveryoneAskingMoreThan(newWage,workerTarget);
        else
        {
            //you could wait for people to leave their job because you lowered their wages, but since we have them already sorted might just as well kick them out ourselves
            for(int i=workers.size() - workersToFire; i  < workers.size(); i++)
            {
                Person toFire = workers.get(i);
                hr.getPlant().removeWorker(toFire);
                toFire.fired(hr.getFirm());
            }

            //on very rare occasions you lower wages enough to kick some people out but more people come in. When that happens, run it again
            if(hr.getPlant().workerSize() > workerTarget)
                quickfire();

            assert hr.getPlant().workerSize() == workerTarget : "workers: " + hr.getPlant().workerSize() + ", workerTarget: " + workerTarget;
        }

    }


    /**
     * This is called by the plant control when it is started.
     */
    @Override
    public void start() {
        //start stepping your PID!
        hr.getFirm().getModel().scheduleSoon(ActionOrder.THINK,this);

    }

    /**
     * always try to buy.
     */
    @Override
    public void changeInWorkforceEvent(Plant p, int workerSize) {
        assert p == hr.getPlant();

        if(workerSize < p.maximumWorkersPossible() && plantControl.canBuy())
            hr.buy();
    }

    /**
     * ignored
     */
    @Override
    public void changeInWageEvent(Plant p, int workerSize, long wage) {
    }

    /**
     * ignored
     */
    @Override
    public void plantShutdownEvent(Plant p) {
    }

    /**
     * always try to buy.
     */
    @Override
    public void changeInMachineryEvent(Plant p, Machinery machinery) {
        assert p == hr.getPlant();
        if(p.workerSize() < p.maximumWorkersPossible() && plantControl.canBuy())
            hr.buy();
    }


    /**
     * This is called when the object stops being useful. Irreversible
     */
    @Override
    public void turnOff() {
        active = false;
    }

    public int getTarget() {
        return workerTarget;
    }


    /**
     * Set the new "0" of the PID target
     */
    public void setInitialWage(long wage)
    {
        Preconditions.checkArgument(wage >=0);
        pid.setOffset(wage);
    }

}
