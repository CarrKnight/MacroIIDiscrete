/*
 * Copyright (c) 2014 by Ernesto Carrella
 * Licensed under MIT license. Basically do what you want with it but cite me and don't sue me. Which is just politeness, really.
 * See the file "LICENSE" for more information
 */

package model.utilities.stats.processes;

import model.utilities.DelayBin;

import java.util.function.Supplier;

/**
 * The dynamic process generated by a one-step error correcting model. This means that there is a linear relationship between
 * x and y, and whenever x changes, y converges by fixed proportion to the linear function of x.
 * Created by carrknight on 9/1/14.
 */
public class ErrorCorrectingDynamicProcess implements DynamicProcess {

    private double intercept;

    private double deltaXCoefficient;

    private double lagYCoefficient;

    private double lagXCoefficient;

    private final DelayBin<Double> delayBinX;


    private double previousOutput;

    private double previousInput;

    private Supplier<Double> noise = () -> 0d;


    public ErrorCorrectingDynamicProcess(double intercept, double deltaXCoefficient, double lagYCoefficient, double lagXCoefficient,
                                         double currentOutput, double currentPreviousInput, DelayBin<Double> previousInputs) {
        this.intercept = intercept;
        this.deltaXCoefficient = deltaXCoefficient;
        this.lagYCoefficient = lagYCoefficient;
        this.lagXCoefficient = lagXCoefficient;
        this.previousOutput = currentOutput;
        this.previousInput = currentPreviousInput;
        delayBinX = new DelayBin<Double>(previousInputs);
    }

    public ErrorCorrectingDynamicProcess(double intercept, double deltaXCoefficient, double lagYCoefficient, double lagXCoefficient,
                                         double currentOutput, double previousInput) {
        this.intercept = intercept;
        this.deltaXCoefficient = deltaXCoefficient;
        this.lagYCoefficient = lagYCoefficient;
        this.lagXCoefficient = lagXCoefficient;
        this.previousOutput = currentOutput;
        this.previousInput = previousInput;
        delayBinX = new DelayBin<>(0,0d);
    }



    @Override
    public double newStep(double todayInput, double... covariants) {
        todayInput = delayBinX.addAndRetrieve(todayInput);
        double deltaX = todayInput - previousInput;


        double currentOutput = previousOutput + intercept + deltaXCoefficient * deltaX +
                lagYCoefficient * previousOutput + lagXCoefficient * previousInput;

        currentOutput += noise.get();


        previousInput = todayInput;

        previousOutput = currentOutput;

        return currentOutput;


    }



    @Override
    public Supplier<Double> getRandomNoise() {
        return noise;
    }

    @Override
    public void setRandomNoise(Supplier<Double> randomNoise) {
        this.noise = randomNoise;
    }
}
