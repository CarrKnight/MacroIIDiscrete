<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_26) on Mon Oct 03 17:23:47 EDT 2011 -->
<TITLE>
Schedule
</TITLE>

<META NAME="date" CONTENT="2011-10-03">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Schedule";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../sim/engine/RandomSequence.html" title="class in sim.engine"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../sim/engine/Schedule.Key.html" title="class in sim.engine"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?sim/engine/Schedule.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Schedule.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
sim.engine</FONT>
<BR>
Class Schedule</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>sim.engine.Schedule</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.io.Serializable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Schedule</B><DT>extends java.lang.Object<DT>implements java.io.Serializable</DL>
</PRE>

<P>
Schedule defines a threadsafe scheduling queue in which events can be scheduled to occur
   at future time.  The time of the most recent event which has already occured
   is given by the <b>getTime()</b> method.  If the current time is <tt>BEFORE_SIMULATION</tt> (defined
   to be <tt>EPOCH - 1</tt>),
   then the schedule is set to the "time before time" (the schedule hasn't started running
   yet).  If the current time is <tt>AFTER_SIMULATION</tt> (positive infinity), then the schedule has run
   out of time.  <tt>EPOCH</tt> (0.0) is defined as the first timestep for which you can legally schedule a value.
   <tt>EPOCH_PLUS_ESPILON</tt> is defined as the smallest possible second timestep for which you can legally sechedule a value.
   If you're scheduling events to occur on integer timesteps, you may want to ensure that your simulation 
   does not run beyond <tt>MAXIMUM_INTEGER</tt> (9007199254740992L or 9.007199254740992E15).  For values of a 
   double d >= <tt>MAXIMUM_INTEGER</tt>, d + 1 == d !

   <p>An event is defined as a <b>Steppable</b> object. You can schedule events to either 
   occur a single time or to occur repeatedly at some interval.  If the event occurs repeatedly,
   the schedule will provide you with a <b>Stoppable</b> object on which you can call <b>stop()</b>
   to cancel all future repeats of the event.  If instead you wish to "stop" a single-time event from occuring
   before its time has come, you should do so through the use of a <b>TentativeStep</b> object.  At present
   you cannot delete objects from the Schedule -- just stop them and let them drop out in due course.

   <p>The schedule is pulsed by calling its <b>step(...)</b> method.  Each pulse, the schedule
   finds the minimum time at which events are scheduled, moves ahead to that time, and then calls
   all the events scheduled at that time.    Multiple events may be scheduled for the same time.
   No event may be scheduled for a time earlier than getTime().  If at time getTime() you schedule a new
   event for time getTime(), then actually this event will occur at time getTime()+epsilon, that is, the
   smallest possible slice of time greater than getTime().

   <p><b>IMPORTANT NOTE:</b> we have disabled the setShuffling() procedure by making the methods private.  The reason for this is that although turning off shuffling causes the Steppables to be stepped in a <i>predictable order</i>, they will note necessarily be stepped in <i>the order in which they were submitted</i>, which was the whole point of the methods.  The reason for this is that a binary heap is not "stable": it doesn't break ties by returning elements in the same order in which they appeared.  This potentially could cause bugs in simulations and we want to make it very clear.

   <!-- 
   <p>Events at a adjust are further subdivided and scheduled according to their <i>ordering</i>, an integer.
   Objects for scheduled for lower orderings for a given time will be executed before objects with
   higher orderings for the same time.  If objects are scheduled for the same time and
   have the same ordering value, their execution will be randomly ordered with respect to one another
   unless (in the very rare case) you have called setShuffling(false);.  Generally speaking, most experiments with
   good model methodologies will want random shuffling left on, and if you need an explicit ordering, it may be
   better to rely on Steppable's orderings or to use a Sequence.
   -->

   <p>You might be wondering: why bother with using orderings?  After all, can't you achieve the same thing by just
   stretching elements out in time?  There are two reasons to use orderings.  First, it allows you to use the getTime()
   method to keep tabs on the current time in a way that might be convenient to you.  But second and more importantly,
   MASON's GUI facility will update its displays and inspectors only after all Steppables scheduled for a 
   given timestamp have completed, and so orderings give you a way of subdividing the interval of time between
   GUI updates.

   <p>A schedule may be <i>sealed</i> meaning that it will refuse to accept any further scheduled events
   even if its time is not yet AFTER_SIMULATION.  This is largely done internally by MASON code: you probably
   will never want to do this.  Once a schedule is sealed it cannot be unsealed until it is reset().

   <p>You can clear out the entire Schedule, unseal it, and restart it to BEFORE_SIMULATION by calling reset().
   However, this does not prevent AsynchronousSteppables from suddenly rescheduling themselves
   in the queue.  Stopping the simulation from within a Steppable object's step() method is best done by
   calling SimState.kill().  From the main thread, the most straightforward way to stop a simulation is to just
   stop calling schedule.step(...), and proceed directly to SimState.finish().

   <p>You can get the number of times that step(...) has been called on the schedule by calling the getSteps() method.
   This value is incremented just as the Schedule exits its step(...) method and only if the method returned true.
   Additionally, you can get a string version of the current time with the getTimestamp(...) method.

   <p><b>Note on Synchronization</b>.  In order to maximize the ability for threads to access the Schedule at any time, 
   Schedule uses two locks for synchronization.  First, the <b>step() method synchronizes on the Schedule</b> itself.  This
   prevents step() from being called simultaneously from different threads; also step() tests to make sure that it's not
   called reentrantly from within the same thread.  Second, <b>many methods synchronize on an internal lock</b>, including step().
   This allows step() to synchronize on the lock only to suck out the relevant Steppables from the Heap and to advance the timestep;
   all other portions of step() are outside of the lock.  Thus when step() actually steps the Steppables, even in different threads
   (like AsynchronousSteppable or ParallelSequence), they can turn around and submit step-requests to the Schedule even while it's still
   in its step() method.

   <p>One downside to this flexibility is that it's very inefficient to check, at each step of a Steppable, whether the Schedule
   has been reset or not.  Thus now if you call reset() or [better] SimState.kill(), the Schedule will continue to step Steppables
   until it has exhausted ones scheduled for the current timestep.  Only at that point will it cease.

   <p><b>Heaps and Calendar Queues</b>.  Schedule uses a plain-old binary heap for its queueing mechanism.  This is reasonably efficient,
   but it could be made more efficient with a Calendar Queue designed for the purposes of your simulation.  We settled on a Heap because
   we do not know what the expected scheduling pattern will be for any given simulation, and so had to go for the most general case.  If you'd
   care to customize your queue, you can do so by overriding the createHeap() method in a custom Schedule.  We imagine this would be rare.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../serialized-form.html#sim.engine.Schedule">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.Key.html" title="class in sim.engine">Schedule.Key</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Timestamps stored as keys in the heap.</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#AFTER_SIMULATION">AFTER_SIMULATION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The time which indicates that the Schedule is finished.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#BEFORE_SIMULATION">BEFORE_SIMULATION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The time which indicates that the Schedule hasn't started yet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#EPOCH">EPOCH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The first possible schedulable time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#EPOCH_PLUS_EPSILON">EPOCH_PLUS_EPSILON</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The second possible schedulable time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#lock">lock</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#MAXIMUM_INTEGER">MAXIMUM_INTEGER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The last time beyond which the schedule is no longer able to precisely maintain integer values due to loss of precision.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#Schedule()">Schedule</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a Schedule.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#clear()">clear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Empties out the schedule but does not reset the time or steps.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../sim/util/Heap.html" title="class in sim.util">Heap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#createHeap()">createHeap</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Heap to be used by the Schedule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#getSteps()">getSteps</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of steps the Schedule has pulsed so far.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#getTime()">getTime</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current timestep</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#getTimestamp(double, java.lang.String, java.lang.String)">getTimestamp</A></B>(double&nbsp;time,
             java.lang.String&nbsp;beforeSimulationString,
             java.lang.String&nbsp;afterSimulationString)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a given time in string format.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#getTimestamp(java.lang.String, java.lang.String)">getTimestamp</A></B>(java.lang.String&nbsp;beforeSimulationString,
             java.lang.String&nbsp;afterSimulationString)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current time in string format.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#isSealed()">isSealed</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether or not the schedule is sealed (nothing more can be scheduled, even 
        if the schedule isn't at AFTER_SIMULATION yet).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#reset()">reset</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Empties out the schedule and resets it to a pristine state BEFORE_SIMULATION, with steps = 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#scheduleComplete()">scheduleComplete</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the schedule has nothing left to do.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#scheduleOnce(double, int, sim.engine.Steppable)">scheduleOnce</A></B>(double&nbsp;time,
             int&nbsp;ordering,
             <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schedules the event to occur at the provided time, and in the ordering provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#scheduleOnce(double, sim.engine.Steppable)">scheduleOnce</A></B>(double&nbsp;time,
             <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schedules the event to occur at the provided time, 0 ordering.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#scheduleOnce(sim.engine.Schedule.Key, sim.engine.Steppable)">scheduleOnce</A></B>(<A HREF="../../sim/engine/Schedule.Key.html" title="class in sim.engine">Schedule.Key</A>&nbsp;key,
             <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schedules an item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#scheduleOnce(sim.engine.Steppable)">scheduleOnce</A></B>(<A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schedules the event to occur at getTime() + 1.0, 0 ordering.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#scheduleOnce(sim.engine.Steppable, int)">scheduleOnce</A></B>(<A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event,
             int&nbsp;ordering)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schedules the event to occur at getTime() + 1.0, and in the ordering provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#scheduleOnceIn(double, sim.engine.Steppable)">scheduleOnceIn</A></B>(double&nbsp;delta,
               <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schedules the event to occur at getTime() + delta, 0 ordering.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#scheduleOnceIn(double, sim.engine.Steppable, int)">scheduleOnceIn</A></B>(double&nbsp;delta,
               <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event,
               int&nbsp;ordering)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schedules the event to occur at getTime() + delta, and in the ordering provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#scheduleRepeating(double, int, sim.engine.Steppable)">scheduleRepeating</A></B>(double&nbsp;time,
                  int&nbsp;ordering,
                  <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schedules the event to recur at an interval of 1.0 starting at the provided time, 
        and in the ordering provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#scheduleRepeating(double, int, sim.engine.Steppable, double)">scheduleRepeating</A></B>(double&nbsp;time,
                  int&nbsp;ordering,
                  <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event,
                  double&nbsp;interval)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schedules the event to recur at the specified interval starting at the provided time, 
        and in the ordering provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#scheduleRepeating(double, sim.engine.Steppable)">scheduleRepeating</A></B>(double&nbsp;time,
                  <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schedules the event to recur at the specified interval starting at the provided time, and at 0 ordering.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#scheduleRepeating(double, sim.engine.Steppable, double)">scheduleRepeating</A></B>(double&nbsp;time,
                  <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event,
                  double&nbsp;interval)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schedules the event to recur at the specified interval starting at the provided time, 
        in ordering 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#scheduleRepeating(sim.engine.Steppable)">scheduleRepeating</A></B>(<A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schedules the event to recur at an interval of 1.0 starting at getTime() + 1.0, and at 0 ordering.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#scheduleRepeating(sim.engine.Steppable, double)">scheduleRepeating</A></B>(<A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event,
                  double&nbsp;interval)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schedules the event to recur at the specified interval starting at getTime() + interval, and at 0 ordering.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#scheduleRepeating(sim.engine.Steppable, int, double)">scheduleRepeating</A></B>(<A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event,
                  int&nbsp;ordering,
                  double&nbsp;interval)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schedules the event to recur at the specified interval starting at getTime() + interval, and at the provided ordering.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#seal()">seal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Seals the schedule: after a schedule is sealed, no further Steppables may be scheduled on it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#step(sim.engine.SimState)">step</A></B>(<A HREF="../../sim/engine/SimState.html" title="class in sim.engine">SimState</A>&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Steps the schedule, gathering and ordering all the items to step on the next time step (skipping
        blank time steps), and then stepping all of them in the decided order.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sim/engine/Schedule.html#time()">time</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>use getTime()</I></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="EPOCH"><!-- --></A><H3>
EPOCH</H3>
<PRE>
public static final double <B>EPOCH</B></PRE>
<DL>
<DD>The first possible schedulable time.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#sim.engine.Schedule.EPOCH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BEFORE_SIMULATION"><!-- --></A><H3>
BEFORE_SIMULATION</H3>
<PRE>
public static final double <B>BEFORE_SIMULATION</B></PRE>
<DL>
<DD>The time which indicates that the Schedule hasn't started yet. Less than EPOCH.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#sim.engine.Schedule.BEFORE_SIMULATION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="AFTER_SIMULATION"><!-- --></A><H3>
AFTER_SIMULATION</H3>
<PRE>
public static final double <B>AFTER_SIMULATION</B></PRE>
<DL>
<DD>The time which indicates that the Schedule is finished.  Equal positive infinity, and thus greater than any schedulable time.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#sim.engine.Schedule.AFTER_SIMULATION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="EPOCH_PLUS_EPSILON"><!-- --></A><H3>
EPOCH_PLUS_EPSILON</H3>
<PRE>
public static final double <B>EPOCH_PLUS_EPSILON</B></PRE>
<DL>
<DD>The second possible schedulable time.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="MAXIMUM_INTEGER"><!-- --></A><H3>
MAXIMUM_INTEGER</H3>
<PRE>
public static final double <B>MAXIMUM_INTEGER</B></PRE>
<DL>
<DD>The last time beyond which the schedule is no longer able to precisely maintain integer values due to loss of precision.  That is, MAXIMUM_INTEGER + 1.0 == MAXIMUM_INTEGER.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#sim.engine.Schedule.MAXIMUM_INTEGER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="lock"><!-- --></A><H3>
lock</H3>
<PRE>
protected java.lang.Object <B>lock</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Schedule()"><!-- --></A><H3>
Schedule</H3>
<PRE>
public <B>Schedule</B>()</PRE>
<DL>
<DD>Creates a Schedule.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="createHeap()"><!-- --></A><H3>
createHeap</H3>
<PRE>
protected <A HREF="../../sim/util/Heap.html" title="class in sim.util">Heap</A> <B>createHeap</B>()</PRE>
<DL>
<DD>Returns a Heap to be used by the Schedule.  By default, returns a
        binary heap.  Override this to provide your own
        subclass of Heap tuned for your particular problem.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="time()"><!-- --></A><H3>
time</H3>
<PRE>
public double <B>time</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use getTime()</I>
<P>
<DD>Returns the current timestep
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTime()"><!-- --></A><H3>
getTime</H3>
<PRE>
public double <B>getTime</B>()</PRE>
<DL>
<DD>Returns the current timestep
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isSealed()"><!-- --></A><H3>
isSealed</H3>
<PRE>
public boolean <B>isSealed</B>()</PRE>
<DL>
<DD>Returns whether or not the schedule is sealed (nothing more can be scheduled, even 
        if the schedule isn't at AFTER_SIMULATION yet).   Calling reset() will unseal
        a Schedule, and calling seal() will seal it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTimestamp(java.lang.String, java.lang.String)"><!-- --></A><H3>
getTimestamp</H3>
<PRE>
public java.lang.String <B>getTimestamp</B>(java.lang.String&nbsp;beforeSimulationString,
                                     java.lang.String&nbsp;afterSimulationString)</PRE>
<DL>
<DD>Returns the current time in string format. If the time is BEFORE_SIMULATION, then beforeSimulationString is
        returned.  If the time is AFTER_SIMULATION, then afterSimulationString is returned.  Otherwise a numerical
        representation of the time is returned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTimestamp(double, java.lang.String, java.lang.String)"><!-- --></A><H3>
getTimestamp</H3>
<PRE>
public java.lang.String <B>getTimestamp</B>(double&nbsp;time,
                                     java.lang.String&nbsp;beforeSimulationString,
                                     java.lang.String&nbsp;afterSimulationString)</PRE>
<DL>
<DD>Returns a given time in string format. If the time is earlier than EPOCH (such as BEFORE_SIMULATION), then beforeSimulationString is
        returned.  If the time is AFTER_SIMULATION, then afterSimulationString is returned.  Otherwise a numerical
        representation of the time is returned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSteps()"><!-- --></A><H3>
getSteps</H3>
<PRE>
public long <B>getSteps</B>()</PRE>
<DL>
<DD>Returns the number of steps the Schedule has pulsed so far.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clear()"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>()</PRE>
<DL>
<DD>Empties out the schedule but does not reset the time or steps.  If you're
        looking for a way to kill your simulation from a Steppable, use SimState.kill() instead.  Note that
        any agents presently at THIS TIME STEP will STILL be stepped -- including possibly reinserting themselves
        in the schedule.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="seal()"><!-- --></A><H3>
seal</H3>
<PRE>
public void <B>seal</B>()</PRE>
<DL>
<DD>Seals the schedule: after a schedule is sealed, no further Steppables may be scheduled on it. 
        To unseal a schedule, you must reset() it.  If you're looking for a way to kill your simulation
        from a Steppable, use SimState.kill() instead.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reset()"><!-- --></A><H3>
reset</H3>
<PRE>
public void <B>reset</B>()</PRE>
<DL>
<DD>Empties out the schedule and resets it to a pristine state BEFORE_SIMULATION, with steps = 0.  If you're
        looking for a way to kill your simulation from a Steppable, use SimState.kill() instead.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleComplete()"><!-- --></A><H3>
scheduleComplete</H3>
<PRE>
public boolean <B>scheduleComplete</B>()</PRE>
<DL>
<DD>Returns true if the schedule has nothing left to do.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="step(sim.engine.SimState)"><!-- --></A><H3>
step</H3>
<PRE>
public boolean <B>step</B>(<A HREF="../../sim/engine/SimState.html" title="class in sim.engine">SimState</A>&nbsp;state)</PRE>
<DL>
<DD>Steps the schedule, gathering and ordering all the items to step on the next time step (skipping
        blank time steps), and then stepping all of them in the decided order.  
        Returns FALSE if nothing was stepped -- the schedule is exhausted or time has run out.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleOnce(sim.engine.Steppable)"><!-- --></A><H3>
scheduleOnce</H3>
<PRE>
public boolean <B>scheduleOnce</B>(<A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</PRE>
<DL>
<DD>Schedules the event to occur at getTime() + 1.0, 0 ordering. If this is a valid time
        and event, schedules the event and returns TRUE.
        This method at present returns FALSE if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleOnceIn(double, sim.engine.Steppable)"><!-- --></A><H3>
scheduleOnceIn</H3>
<PRE>
public boolean <B>scheduleOnceIn</B>(double&nbsp;delta,
                              <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</PRE>
<DL>
<DD>Schedules the event to occur at getTime() + delta, 0 ordering. If this is a valid time
        and event, schedules the event and returns TRUE.
        This method at present returns FALSE if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleOnce(sim.engine.Steppable, int)"><!-- --></A><H3>
scheduleOnce</H3>
<PRE>
public boolean <B>scheduleOnce</B>(<A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event,
                            int&nbsp;ordering)</PRE>
<DL>
<DD>Schedules the event to occur at getTime() + 1.0, and in the ordering provided. If this is a valid time
        and event, schedules the event and returns TRUE.
        This method at present returns FALSE if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleOnceIn(double, sim.engine.Steppable, int)"><!-- --></A><H3>
scheduleOnceIn</H3>
<PRE>
public boolean <B>scheduleOnceIn</B>(double&nbsp;delta,
                              <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event,
                              int&nbsp;ordering)</PRE>
<DL>
<DD>Schedules the event to occur at getTime() + delta, and in the ordering provided. If this is a valid time
        and event, schedules the event and returns TRUE.
        This method at present returns FALSE if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleOnce(double, sim.engine.Steppable)"><!-- --></A><H3>
scheduleOnce</H3>
<PRE>
public boolean <B>scheduleOnce</B>(double&nbsp;time,
                            <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</PRE>
<DL>
<DD>Schedules the event to occur at the provided time, 0 ordering.  If the getTime() == the provided
        time, then the event is instead scheduled to occur at getTime() + epsilon (the minimum possible next
        timestamp). If this is a valid time
        and event, schedules the event and returns TRUE.
        This method at present returns FALSE if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleOnce(double, int, sim.engine.Steppable)"><!-- --></A><H3>
scheduleOnce</H3>
<PRE>
public boolean <B>scheduleOnce</B>(double&nbsp;time,
                            int&nbsp;ordering,
                            <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</PRE>
<DL>
<DD>Schedules the event to occur at the provided time, and in the ordering provided.  If the getTime() == the provided
        time, then the event is instead scheduled to occur at getTime() + epsilon (the minimum possible next
        timestamp). If this is a valid time, ordering,
        and event, schedules the event and returns TRUE.
        This method at present returns FALSE if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleOnce(sim.engine.Schedule.Key, sim.engine.Steppable)"><!-- --></A><H3>
scheduleOnce</H3>
<PRE>
protected boolean <B>scheduleOnce</B>(<A HREF="../../sim/engine/Schedule.Key.html" title="class in sim.engine">Schedule.Key</A>&nbsp;key,
                               <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</PRE>
<DL>
<DD>Schedules an item. 
        This method at present returns FALSE if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleRepeating(sim.engine.Steppable)"><!-- --></A><H3>
scheduleRepeating</H3>
<PRE>
public <A HREF="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</A> <B>scheduleRepeating</B>(<A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</PRE>
<DL>
<DD>Schedules the event to recur at an interval of 1.0 starting at getTime() + 1.0, and at 0 ordering.
        If this is a valid event, schedules the event and returns a Stoppable, else returns null.
        The recurrence will continue until getTime() >= AFTER_SIMULATION, the Schedule is cleared out,
        or the Stoppable's stop() method is called, whichever happens first.

        <p>This method at present returns null if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null. 

        <p> Note that calling stop() on the Stoppable
        will not only stop the repeating, but will <i>also</i> make the Schedule completely
        forget (lose the pointer to) the Steppable scheduled here.  This is particularly useful
        if you need to make the Schedule NOT serialize certain Steppable objects.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleRepeating(sim.engine.Steppable, double)"><!-- --></A><H3>
scheduleRepeating</H3>
<PRE>
public <A HREF="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</A> <B>scheduleRepeating</B>(<A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event,
                                   double&nbsp;interval)</PRE>
<DL>
<DD>Schedules the event to recur at the specified interval starting at getTime() + interval, and at 0 ordering.
        If this is a valid interval (must be > 0)
        and event, schedules the event and returns a Stoppable, else returns null.
        The recurrence will continue until getTime() >= AFTER_SIMULATION, the Schedule is cleared out,
        or the Stoppable's stop() method is called, whichever happens first.

        <p>This method at present returns null if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null. 

        <p> Note that calling stop() on the Stoppable
        will not only stop the repeating, but will <i>also</i> make the Schedule completely
        forget (lose the pointer to) the Steppable scheduled here.  This is particularly useful
        if you need to make the Schedule NOT serialize certain Steppable objects.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleRepeating(sim.engine.Steppable, int, double)"><!-- --></A><H3>
scheduleRepeating</H3>
<PRE>
public <A HREF="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</A> <B>scheduleRepeating</B>(<A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event,
                                   int&nbsp;ordering,
                                   double&nbsp;interval)</PRE>
<DL>
<DD>Schedules the event to recur at the specified interval starting at getTime() + interval, and at the provided ordering.
        If this is a valid interval (must be > 0)
        and event, schedules the event and returns a Stoppable, else returns null.
        The recurrence will continue until getTime() >= AFTER_SIMULATION, the Schedule is cleared out,
        or the Stoppable's stop() method is called, whichever happens first.

        <p>This method at present returns null if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null. 

        <p> Note that calling stop() on the Stoppable
        will not only stop the repeating, but will <i>also</i> make the Schedule completely
        forget (lose the pointer to) the Steppable scheduled here.  This is particularly useful
        if you need to make the Schedule NOT serialize certain Steppable objects.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleRepeating(double, sim.engine.Steppable)"><!-- --></A><H3>
scheduleRepeating</H3>
<PRE>
public <A HREF="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</A> <B>scheduleRepeating</B>(double&nbsp;time,
                                   <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</PRE>
<DL>
<DD>Schedules the event to recur at the specified interval starting at the provided time, and at 0 ordering.
        If the getTime() == the provided
        time, then the first event is instead scheduled to occur at getTime() + epsilon (the minimum possible next
        timestamp). If this is a valid time, ordering, interval (must be positive), 
        and event, schedules the event and returns a Stoppable, else returns null.
        The recurrence will continue until getTime() >= AFTER_SIMULATION, the Schedule is cleared out,
        or the Stoppable's stop() method is called, whichever happens first.

        <p>This method at present returns null if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null. 

        <p> Note that calling stop() on the Stoppable
        will not only stop the repeating, but will <i>also</i> make the Schedule completely
        forget (lose the pointer to) the Steppable scheduled here.  This is particularly useful
        if you need to make the Schedule NOT serialize certain Steppable objects.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleRepeating(double, sim.engine.Steppable, double)"><!-- --></A><H3>
scheduleRepeating</H3>
<PRE>
public <A HREF="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</A> <B>scheduleRepeating</B>(double&nbsp;time,
                                   <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event,
                                   double&nbsp;interval)</PRE>
<DL>
<DD>Schedules the event to recur at the specified interval starting at the provided time, 
        in ordering 0.  If the getTime() == the provided
        time, then the first event is instead scheduled to occur at getTime() + epsilon (the minimum possible next
        timestamp). If this is a valid time, interval (must be > 0), 
        and event, schedules the event and returns a Stoppable, else returns null.
        The recurrence will continue until getTime() >= AFTER_SIMULATION, the Schedule is cleared out,
        or the Stoppable's stop() method is called, whichever happens first.

        <p>This method at present returns null if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null. 

        <p> Note that calling stop() on the Stoppable
        will not only stop the repeating, but will <i>also</i> make the Schedule completely
        forget (lose the pointer to) the Steppable scheduled here.  This is particularly useful
        if you need to make the Schedule NOT serialize certain Steppable objects.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleRepeating(double, int, sim.engine.Steppable)"><!-- --></A><H3>
scheduleRepeating</H3>
<PRE>
public <A HREF="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</A> <B>scheduleRepeating</B>(double&nbsp;time,
                                   int&nbsp;ordering,
                                   <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event)</PRE>
<DL>
<DD>Schedules the event to recur at an interval of 1.0 starting at the provided time, 
        and in the ordering provided.  If the getTime() == the provided
        time, then the first event is instead scheduled to occur at getTime() + epsilon (the minimum possible next
        timestamp). If this is a valid time, ordering,
        and event, schedules the event and returns a Stoppable, else returns null.
        The recurrence will continue until getTime() >= AFTER_SIMULATION, the Schedule is cleared out,
        or the Stoppable's stop() method is called, whichever happens first.

        <p>This method at present returns null if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null. 

        <p> Note that calling stop() on the Stoppable
        will not only stop the repeating, but will <i>also</i> make the Schedule completely
        forget (lose the pointer to) the Steppable scheduled here.  This is particularly useful
        if you need to make the Schedule NOT serialize certain Steppable objects.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleRepeating(double, int, sim.engine.Steppable, double)"><!-- --></A><H3>
scheduleRepeating</H3>
<PRE>
public <A HREF="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</A> <B>scheduleRepeating</B>(double&nbsp;time,
                                   int&nbsp;ordering,
                                   <A HREF="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</A>&nbsp;event,
                                   double&nbsp;interval)</PRE>
<DL>
<DD>Schedules the event to recur at the specified interval starting at the provided time, 
        and in the ordering provided.  If the getTime() == the provided
        time, then the first event is instead scheduled to occur at getTime() + epsilon (the minimum possible next
        timestamp). If this is a valid time, ordering, interval (must be > 0), 
        and event, schedules the event and returns a Stoppable.
        The recurrence will continue until getTime() >= AFTER_SIMULATION, the Schedule is cleared out,
        or the Stoppable's stop() method is called, whichever happens first.

        <p>This method at present returns null if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null. 

        <p> Note that calling stop() on the Stoppable
        will not only stop the repeating, but will <i>also</i> make the Schedule completely 
        forget (lose the pointer to) the Steppable scheduled here.  This is particularly useful
        if you need to make the Schedule NOT serialize certain Steppable objects.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../sim/engine/RandomSequence.html" title="class in sim.engine"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../sim/engine/Schedule.Key.html" title="class in sim.engine"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?sim/engine/Schedule.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Schedule.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
