<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_26) on Mon Oct 03 17:23:50 EDT 2011 -->
<TITLE>
Network
</TITLE>

<META NAME="date" CONTENT="2011-10-03">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Network";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../sim/field/network/Network.IndexOutIn.html" title="class in sim.field.network"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?sim/field/network/Network.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Network.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
sim.field.network</FONT>
<BR>
Class Network</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>sim.field.network.Network</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.io.Serializable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Network</B><DT>extends java.lang.Object<DT>implements java.io.Serializable</DL>
</PRE>

<P>
The Network is a field which stores binary graph and multigraph structures of all kinds, using hash tables to allow
    reasonably rapid dynamic modification.

    <p>The nodes of a Network's graph can be any arbitrary, properly hashable object.  The edges of the
    graph are members of the Edge class.  This class is little more than a wrapper around an arbitrary object as well (the Edge's 'info'
    object).  Thus your graph's nodes and edges can essentially be objects entirely of your choosing.

    <p>Edge objects also contain pointers to the Nodes that they are to and from (plus some auxillary index information
    for speed).

    <p>Nodes and Edges are stored in the Network using two data structures: a Bag containing all the nodes in the Field;
    and a HashMap which maps each Node to a container holding the Node's index in the Bag, plus a Bag of the Node's outgoing
    Edges and a Bag of the Node's incoming Edges.  Ordinarily you won't fool with these structures other than to scan through
    them (in particular, to scan rapidly through the allNodes bag rather than use an iterator).

    <p>To add a node to the Network, simply use addNode(node).  To remove a node, use removeNode(node).
    To add an edge to the Network, use addEdge(fromNode,toNode,edgeInfoObject), where edgeInfoObject is your
    arbitrary edge object. Alternatively, you can make an Edge object from scratch and add it with addEdge(new Edge(fromNode, toNode, edgeInfoObject)).
    You remove edges with removeEdge(edge).  If you add an edge, and its nodes have not been added yet, they will
    automatically be added as well.

    <p>Traversing a Network is easy.  
    To get a Bag of all the incoming (or outgoing) Edges to a node, use getEdgesIn(node) or getEdgesOut(node).
    Do <b>not</b> add or remove Edges from this Bag -- it's used internally and we trust you here.  Also don't expect the
    Bag to not change its values mysteriously later on.  Make a copy of the Bag if you want to keep it and/or modify it.
    Once you have an Edge, you can call its to() method and from() methods to get the nodes it's from and to, and you can
    at any time get and modify its info object.  The to() and from() are fast and inlined.

    <p>However, the getEdgesIn(node) and getEdgesOut(node) methods are not super fast: they require a hash lookup.  If you
    are planning on applying an algorithm on the Network which doesn't change the topology at all but traverses it a lot
    and changes just the <b>contents</b> of the edge info objects and the node object contents, you might consider first 
    getting an adjacency list for the Network with getAdjacencyList(...), or an adjacency matrix with getAdjacencyMatrix(...)
    or getMultigraphAdjacencyMatrix(...).  But remember that as soon as the topology changes (adding/deleting a node or edge),
    the adjacency list is invalid, and you need to request another one.

    <p><b>Computational Complexity.</b>  Adding a node or an edge is O(1).  Removing an edge is O(1).  Removing a node is O(m), where
    m is the total number of edges in and out of the node.  Removing all nodes is O(1) and fast.  Getting the in-edges or out-edges for a node
    is O(1).  Getting the to or from node for an edge is O(1) and fast.

    <p><b>Warning About Hashing.</b>  Java's hashing method is broken in an important way.  One can override the hashCode() and equals()
    methods of an object so that they hash by the value of an object rather than just the pointer to it.  But if this is done, then if
    you use this object as a key in a hash table, then <i>change</i> those values in the object, it will break the hash table -- the key
    and the object hashed by it will both be lost in the hashtable, unable to be accessed or removed from it.  The moral of the story is:
    do not override hashCode() and equals() to hash by value unless your object is <i>immutable</i> -- its values cannot be changed.  This
    is the case, for example, with Strings, which hash by value but cannot be modified.  It's also the case with Int2D, Int3D, Double2D,
    and Double3D, as well as Double, Integer, etc.  Some of Sun's own objects are broken in this respect: Point, Point2D, etc. are both
    mutable <i>and</i> hashed by value.

    <p>This affects you in only one way in a Network: edges are hashed by nodes.  The Network permits you to use any object
    as a node -- but you have been suitably warned: if you use a mutable but hashed-by-value node object, do NOT modify its values while
    it's being used as a key in the Network.

    <p><b>Directed vs. Undirected Graphs.</b>  Networks are constructed to be either directed or undirected, and they cannot be changed
    afterwards without being entirely cleared first (using reset(...)).  If the network is directed, then an Edge's to() and from() nodes 
    have explicit meaning: the Edge goes from() one node to()
    another.  If the network is undirected, then to() and from() are simply the two nodes at each end of the Edge with no special meaning,
    though they're always consistent.  The convenience method <i>edge</i>.getOtherNode(<i>node</i>) will provide "other" node (if node is to(),
    then from() is returned, and vice versa).  This is particularly useful in undirected graphs where you could be entering an edge as to()
    or as from() and you just want to know what the node on the other end of the edge is.

    <p>There are three methods for getting all the edges attached to a node: getEdgesIn(), getEdgesOut(), and the less efficient getEdges().  These methods
    work differently depending on whether or not the network is directed:

    <p><table width="100%" border=0>
    <tr><td><td><b>Directed</b><td><b>Undirected</b>
    <tr><td><b>getEdgesIn()</b><td>Bag&nbsp;of&nbsp;incoming&nbsp;edges<td>Bag&nbsp;of&nbsp;all&nbsp;edges
    <tr><td><b>getEdgesOut()</b><td>Bag&nbsp;of&nbsp;outgoing&nbsp;edges<td>Bag&nbsp;of&nbsp;all&nbsp;edges
    <tr><td><b>getEdges()</b><td><i>Modifiable</i>&nbsp;Bag&nbsp;of&nbsp;all&nbsp;edges<td><i>Modifiable</i>&nbsp;Bag&nbsp;of&nbsp;all&nbsp;edges
    </table>

    <p><b>Hypergraphs.</b> Network is binary.  In the future we may provide a Hypergraph facility if it's needed, but for now you'll
    need to make "multi-edge nodes" and store them in the field, then hook them to your nodes via Edges.  For example, to store the
    relationship foo(node1, node2, node3), here's one way to do it:
    <ol>
    <li>Make a special foo object.
    <li>field.addEdge(foo,node1,new Double(0));
    <li>field.addEdge(foo,node2,new Double(1));
    <li>field.addEdge(foo,node3,new Double(2));
    </ol>
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../serialized-form.html#sim.field.network.Network">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.IndexOutIn.html" title="class in sim.field.network">Network.IndexOutIn</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The structure stored in the indexOutInHash hash table.</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#allNodes">allNodes</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All the objects in the sparse field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.HashMap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#indexOutInHash">indexOutInHash</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hashes Network.IndexOutIn structures by Node.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#Network()">Network</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a directed graph</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#Network(boolean)">Network</A></B>(boolean&nbsp;directed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a directed or undirected graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#Network(sim.field.network.Network)">Network</A></B>(<A HREF="../../../sim/field/network/Network.html" title="class in sim.field.network">Network</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs copy of an existing graph.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#addEdge(sim.field.network.Edge)">addEdge</A></B>(<A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A>&nbsp;edge)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add an edge.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#addEdge(java.lang.Object, java.lang.Object, java.lang.Object)">addEdge</A></B>(java.lang.Object&nbsp;from,
        java.lang.Object&nbsp;to,
        java.lang.Object&nbsp;info)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add an edge, storing info as the edge's associated information object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#addNode(java.lang.Object)">addNode</A></B>(java.lang.Object&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#clear()">clear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all nodes, deleting all edges from the Field as well.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../sim/field/network/Network.html" title="class in sim.field.network">Network</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#cloneGraph()">cloneGraph</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A>[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#getAdjacencyList(boolean)">getAdjacencyList</A></B>(boolean&nbsp;outEdges)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates and returns an adjacency list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A>[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#getAdjacencyMatrix()">getAdjacencyMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates and returns a simple adjacency matrix, where only one edge between any two nodes is considered -- if you're
        using a multigraph, use getMultigraphAdjacencyMatrix() instead.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#getAllNodes()">getAllNodes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns all the objects in the Sparse Field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#getEdges(java.lang.Object, sim.util.Bag)">getEdges</A></B>(java.lang.Object&nbsp;node,
         <A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A>&nbsp;bag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get all the edges that enter or leave a node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#getEdgesIn(java.lang.Object)">getEdgesIn</A></B>(java.lang.Object&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get all edges that enter a node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#getEdgesOut(java.lang.Object)">getEdgesOut</A></B>(java.lang.Object&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get all edges that leave a node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../sim/field/network/Network.html" title="class in sim.field.network">Network</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#getGraphComplement(boolean)">getGraphComplement</A></B>(boolean&nbsp;allowSelfLoops)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Complements the graph: same nodes, no edges where they were, edges where they were not.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A>[][][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#getMultigraphAdjacencyMatrix()">getMultigraphAdjacencyMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates and returns a multigraph adjacency matrix, which includes all edges from a given node to another -- if you know for sure
        that you have a simple graph (no multiple edges between two nodes), use getAdjacencyMatrix instead.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#getNodeIndex(java.lang.Object)">getNodeIndex</A></B>(java.lang.Object&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#isDirected()">isDirected</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Iterator</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#iterator()">iterator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterates over all objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#nodeExists(java.lang.Object)">nodeExists</A></B>(java.lang.Object&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#removeAllNodes()">removeAllNodes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Synonym for clear(), here only for backward-compatibility.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#removeEdge(sim.field.network.Edge)">removeEdge</A></B>(<A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A>&nbsp;edge)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes an edge and returns it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#removeNode(java.lang.Object)">removeNode</A></B>(java.lang.Object&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes a node, deleting all incoming and outgoing edges from the Field as well.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#reset(boolean)">reset</A></B>(boolean&nbsp;directed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resets the network, clearing it of nodes and edges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#reverseAllEdges()">reverseAllEdges</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This reverse the direction of all edges in the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../sim/field/network/Network.html#updateEdge(sim.field.network.Edge, java.lang.Object, java.lang.Object, java.lang.Object)">updateEdge</A></B>(<A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A>&nbsp;edge,
           java.lang.Object&nbsp;from,
           java.lang.Object&nbsp;to,
           java.lang.Object&nbsp;info)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the given edge, then changes its from, to, and info values to the provided ones,
        then adds the edge to the network again.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="indexOutInHash"><!-- --></A><H3>
indexOutInHash</H3>
<PRE>
public java.util.HashMap <B>indexOutInHash</B></PRE>
<DL>
<DD>Hashes Network.IndexOutIn structures by Node.  These structures
        contain the incoming edges of the Node, its outgoing edges, and the index of
        the Node in the allNodes bag.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="allNodes"><!-- --></A><H3>
allNodes</H3>
<PRE>
public <A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A> <B>allNodes</B></PRE>
<DL>
<DD>All the objects in the sparse field.  For fast scans.  Do not rely on this bag always being the same object.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Network(boolean)"><!-- --></A><H3>
Network</H3>
<PRE>
public <B>Network</B>(boolean&nbsp;directed)</PRE>
<DL>
<DD>Constructs a directed or undirected graph.
<P>
</DL>
<HR>

<A NAME="Network()"><!-- --></A><H3>
Network</H3>
<PRE>
public <B>Network</B>()</PRE>
<DL>
<DD>Constructs a directed graph
<P>
</DL>
<HR>

<A NAME="Network(sim.field.network.Network)"><!-- --></A><H3>
Network</H3>
<PRE>
public <B>Network</B>(<A HREF="../../../sim/field/network/Network.html" title="class in sim.field.network">Network</A>&nbsp;other)</PRE>
<DL>
<DD>Constructs copy of an existing graph.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="isDirected()"><!-- --></A><H3>
isDirected</H3>
<PRE>
public boolean <B>isDirected</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reset(boolean)"><!-- --></A><H3>
reset</H3>
<PRE>
public void <B>reset</B>(boolean&nbsp;directed)</PRE>
<DL>
<DD>Resets the network, clearing it of nodes and edges.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAdjacencyList(boolean)"><!-- --></A><H3>
getAdjacencyList</H3>
<PRE>
public <A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A>[][] <B>getAdjacencyList</B>(boolean&nbsp;outEdges)</PRE>
<DL>
<DD>Creates and returns an adjacency list.  If you're doing lots of operations (especially network traversals)
        which won't effect the topology of the network, an adjacency list structure might be more efficient for you to access rather than lots of
        calls to getEdgesIn() and getEdgesOut() etc.  Building the list is an O(#edges) operation.

        <p>The adjacency list is an array of Edge arrays.  Each edge array holds all outgoing edges from a node
        (if outEdges is true -- otherwise it's the incoming edges to the node).  The edge arrays are ordered in
        their parent array in the same order that the corresponding nodes are ordered in the allNodes bag.

        <p>As soon as you modify any part of the Network's topology (through addEdge(), addNode(), removeEdge(),
        removeNode(), removeAllNodes(), etc.), the adjacency list data is invalid and should not be used.  Instead, request
        a new adjacency list. 

        <p>You can modify these edge arrays any way you like, though the Edge objects are the actual Edges.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAdjacencyMatrix()"><!-- --></A><H3>
getAdjacencyMatrix</H3>
<PRE>
public <A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A>[][] <B>getAdjacencyMatrix</B>()</PRE>
<DL>
<DD>Creates and returns a simple adjacency matrix, where only one edge between any two nodes is considered -- if you're
        using a multigraph, use getMultigraphAdjacencyMatrix() instead.  If you're doing lots of operations (especially network traversals)
        which won't effect the topology of the network, an adjacency matrix structure might be more efficient for you to access rather than lots of
        calls to getEdgesIn() and getEdgesOut() etc.  Building the matrix is an O(#edges + #nodes^2) operation.

        <p>The adjacency matrix is a two-dimensional array of Edges, each dimension as long as the number of nodes in the graph.
        Each entry in the array is either an Edge FROM a node TO another, or it is null (if there is no such edge).  If there are multiple
        edges between any two nodes, an arbitrary one is chosen.  The Edge array returned is organized as Edge[FROM][TO].
        The indices are ordered in the same order that the corresponding nodes are ordered in the allNodes bag.

        <p>As soon as you modify any part of the Network's topology (through addEdge(), addNode(), removeEdge(),
        removeNode(), removeAllNodes(), etc.), the adjacency matrix data is invalid and should not be used.  Instead, request
        a new adjacency matrix. 

        <p>You can modify the array returned any way you like, though the Edge objects are the actual Edges.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMultigraphAdjacencyMatrix()"><!-- --></A><H3>
getMultigraphAdjacencyMatrix</H3>
<PRE>
public <A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A>[][][] <B>getMultigraphAdjacencyMatrix</B>()</PRE>
<DL>
<DD>Creates and returns a multigraph adjacency matrix, which includes all edges from a given node to another -- if you know for sure
        that you have a simple graph (no multiple edges between two nodes), use getAdjacencyMatrix instead.  
        If you're doing lots of operations (especially network traversals) which won't effect the topology of the network, an 
        adjacency matrix structure might be more efficient for you to access rather than lots of calls to getEdgesIn() and 
        getEdgesOut() etc.  Building the matrix is expensive: it's an O(#edges + #nodes^2) operation.

        <p>The adjacency matrix is a two-dimensional array of Edge arrays, both of the dimensions as long as the number of nodes in the graph.
        Each entry in this two-dimensional array is an <b>array</b> of all edges FROM a node TO another.  Thus the
        returned array structure is organized as Edge[FROM][TO][EDGES].
        The FROM and TO indices are ordered in the same order that the corresponding nodes are ordered in the allNodes bag.

        <p>Important note: if there are <i>no</i> edges FROM a given node TO another, an empty array is placed in that entry.
        For efficiency's sake, the <i>same</i> empty array is used.  Thus you should not assume that you can compare edge arrays
        for equality (an unlikely event anyway). 

        <p>As soon as you modify any part of the Network's topology (through addEdge(), addNode(), removeEdge(),
        removeNode(), removeAllNodes(), etc.), the adjacency matrix data is invalid and should not be used.  Instead, request
        a new adjacency matrix. 

        <p>You can modify the array returned any way you like, though the Edge objects are the actual Edges.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getEdgesOut(java.lang.Object)"><!-- --></A><H3>
getEdgesOut</H3>
<PRE>
public <A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A> <B>getEdgesOut</B>(java.lang.Object&nbsp;node)</PRE>
<DL>
<DD>Get all edges that leave a node.  Do NOT modify this Bag -- it is used internally.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getEdgesIn(java.lang.Object)"><!-- --></A><H3>
getEdgesIn</H3>
<PRE>
public <A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A> <B>getEdgesIn</B>(java.lang.Object&nbsp;node)</PRE>
<DL>
<DD>Get all edges that enter a node.  Do NOT modify this Bag -- it is used internally.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getEdges(java.lang.Object, sim.util.Bag)"><!-- --></A><H3>
getEdges</H3>
<PRE>
public <A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A> <B>getEdges</B>(java.lang.Object&nbsp;node,
                    <A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A>&nbsp;bag)</PRE>
<DL>
<DD>Get all the edges that enter or leave a node.  If a Bag is provided, it will be cleared, then filled and returned.
        Else a Bag will be constructed and returned.  If the graph is undirected, then edgesIn and edgesOut should
        be the same thing, and so this is roughly equivalent to bag.addAll(getEdgesIn(node));  If the graph is
        directed, then both the edgesIn AND the edgesOut are added to the Bag.  Generally speaking you should
        try to use the more efficient getEdgesIn(...) and getEdgesOut(...) methods instead if you can.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addNode(java.lang.Object)"><!-- --></A><H3>
addNode</H3>
<PRE>
public void <B>addNode</B>(java.lang.Object&nbsp;node)</PRE>
<DL>
<DD>Add a node
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addEdge(java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
addEdge</H3>
<PRE>
public void <B>addEdge</B>(java.lang.Object&nbsp;from,
                    java.lang.Object&nbsp;to,
                    java.lang.Object&nbsp;info)</PRE>
<DL>
<DD>Add an edge, storing info as the edge's associated information object. 
        If you add an edge, and its nodes have not been added yet, they will
        automatically be added as well.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addEdge(sim.field.network.Edge)"><!-- --></A><H3>
addEdge</H3>
<PRE>
public void <B>addEdge</B>(<A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A>&nbsp;edge)</PRE>
<DL>
<DD>Add an edge. If you add an edge, and its nodes have not been added yet, they will
        automatically be added as well. Throws an exception if the edge is null or if it's
        already added to a Field (including this one).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="updateEdge(sim.field.network.Edge, java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
updateEdge</H3>
<PRE>
public <A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A> <B>updateEdge</B>(<A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A>&nbsp;edge,
                       java.lang.Object&nbsp;from,
                       java.lang.Object&nbsp;to,
                       java.lang.Object&nbsp;info)</PRE>
<DL>
<DD>Removes the given edge, then changes its from, to, and info values to the provided ones,
        then adds the edge to the network again.  Ordinarily you wouldn't need to do this -- you can
        just remove an edge and add a new one.  But in the case that you want to reuse an edge (to track
        it in an inspector, for example), this function might be helpful given that Edge specifically
        denies you the ability to change its to and from values.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeEdge(sim.field.network.Edge)"><!-- --></A><H3>
removeEdge</H3>
<PRE>
public <A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A> <B>removeEdge</B>(<A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</A>&nbsp;edge)</PRE>
<DL>
<DD>Removes an edge and returns it.  The edge will still retain its info, to, and from fields, so you can
        add it again with addEdge.   Returns null if the edge is null or if there is no such 
        edge added to the field.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeNode(java.lang.Object)"><!-- --></A><H3>
removeNode</H3>
<PRE>
public java.lang.Object <B>removeNode</B>(java.lang.Object&nbsp;node)</PRE>
<DL>
<DD>Removes a node, deleting all incoming and outgoing edges from the Field as well.  Returns the node,
        or null if there is no such node in the field.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clear()"><!-- --></A><H3>
clear</H3>
<PRE>
public <A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A> <B>clear</B>()</PRE>
<DL>
<DD>Removes all nodes, deleting all edges from the Field as well.  Returns the nodes as a Bag, which you
        are free to modify as it's no longer used internally by the Network.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeAllNodes()"><!-- --></A><H3>
removeAllNodes</H3>
<PRE>
public <A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A> <B>removeAllNodes</B>()</PRE>
<DL>
<DD>Synonym for clear(), here only for backward-compatibility.
        Removes all nodes, deleting all edges from the Field as well.  Returns the nodes as a Bag, which you
        are free to modify as it's no longer used internally by the Network.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAllNodes()"><!-- --></A><H3>
getAllNodes</H3>
<PRE>
public <A HREF="../../../sim/util/Bag.html" title="class in sim.util">Bag</A> <B>getAllNodes</B>()</PRE>
<DL>
<DD>Returns all the objects in the Sparse Field.  Do NOT modify the bag that you receive out this method -- it
        is used internally.  If you wish in modify the Bag you receive, make a copy of the Bag first, 
        using something like <b>new Bag(<i>foo</i>.getallNodes())</b>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="iterator()"><!-- --></A><H3>
iterator</H3>
<PRE>
public java.util.Iterator <B>iterator</B>()</PRE>
<DL>
<DD>Iterates over all objects.  
        NOT fail-fast, and remove() not supported.  Use this method only if you're
        woozy about accessing allObject.numObjs and allObject.objs directly. 

        For the fastest scan, you can do:
        <p><tt>

        for(int x=0;x&lt;field.allNodes.numObjs;x++) ... field.allNodes.objs[x] ... </tt>

        <p>... but do NOT modify the allNodes.objs array.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nodeExists(java.lang.Object)"><!-- --></A><H3>
nodeExists</H3>
<PRE>
public boolean <B>nodeExists</B>(java.lang.Object&nbsp;node)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNodeIndex(java.lang.Object)"><!-- --></A><H3>
getNodeIndex</H3>
<PRE>
public int <B>getNodeIndex</B>(java.lang.Object&nbsp;node)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reverseAllEdges()"><!-- --></A><H3>
reverseAllEdges</H3>
<PRE>
public void <B>reverseAllEdges</B>()</PRE>
<DL>
<DD>This reverse the direction of all edges in the graph.
 It is more expensive to clone the graph than to reverse the edges in place.
 It is more than twice as fast to reverse the edges than to 
 create the dual graph. As a matter of fact getDualNetwork() took 240 time units
 while  two reverseAllEdges() calls took only 40 time units on a directed
 graph (1time unit = 1 millisecond / 10000 calls).
 
 In that case it is more advantageous to reverse the edges, 
 compute whatever stats on the dual and revert it than to allocate memory.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneGraph()"><!-- --></A><H3>
cloneGraph</H3>
<PRE>
public <A HREF="../../../sim/field/network/Network.html" title="class in sim.field.network">Network</A> <B>cloneGraph</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I></I>
<P>
<DD>Makes a duplicate copy of the graph.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getGraphComplement(boolean)"><!-- --></A><H3>
getGraphComplement</H3>
<PRE>
public <A HREF="../../../sim/field/network/Network.html" title="class in sim.field.network">Network</A> <B>getGraphComplement</B>(boolean&nbsp;allowSelfLoops)</PRE>
<DL>
<DD>Complements the graph: same nodes, no edges where they were, edges where they were not.
 
 An advantage over calling addNode and addEdge n and m times, 
 is to allocate the Bags the right size the first time.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../sim/field/network/Edge.html" title="class in sim.field.network"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../sim/field/network/Network.IndexOutIn.html" title="class in sim.field.network"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?sim/field/network/Network.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Network.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
